Findings

  - High – Build literally can’t succeed right now: go.mod pins go 1.24.0 and
    toolchain go1.24.8, and the Dockerfile pulls golang:1.24.8-alpine3.21 /
    alpine:3.21.0. None of those exist, so go mod download, docker build, and CI
    are dead on arrival (go.mod:3, Dockerfile:2, Dockerfile:37).
  - High – When auth is enabled, CORS preflight gets KO’d. The middleware stack
    runs Auth before CORSWithOrigins, so every OPTIONS request shows up without
    a bearer token and gets a 401 before CORS headers ever appear (cmd/server/
    main.go:254, internal/middleware/middleware.go:275). Browsers will refuse to
    send the actual call.
  - High – Turning on auth also bricks Prometheus scraping. /metrics isn’t in
    the default public-path list, so the auth middleware now guards it and the
    scraper just gets 401s (pkg/config/config.go:89, cmd/server/main.go:245).
  - Medium – Auth error responses are pretending to be JSON but they’re emitted
    via http.Error, so the wire format is text/plain with an extra newline.
    Any client expecting a JSON body (or doing strict content-type checks) is
    going to choke (internal/middleware/middleware.go:287, internal/middleware/
    middleware.go:313).
  - Medium – Prometheus labels use the raw r.URL.Path, which means /
    api/locations/{name} explodes into one time series per location
    name. Cardinality blows up fast in production (internal/middleware/
    middleware.go:157).
  - Medium – The README says the root service-info payload includes the location
    endpoints, but the code never returns them, so your self-documenting landing
    page is lying (README.md:108, pkg/model/model.go:41).
  - Low – The repo ships with a compiled server binary and live SQLite artifacts
    (server, data/timeservice.db, backups/timeservice_20251020_094227.db).
    That’s a recipe for bloated commits and leaking real data; they belong on
    the ignore list, not in source control.

  Questions / Assumptions

  - Are we intentionally forcing location names to lowercase for storage, or
    should we preserve caller casing and let the unique index handle case-
    insensitivity?
  - Do we actually want /metrics to be private when auth is enabled? If so, we
    need docs and a token strategy; if not, it should be public by default.
  - Any reason we aren’t mapping structured routes (e.g., chi/httprouter) so we
    can feed pattern labels into Prometheus instead of raw paths?

  Change Summary

  - No code changes made; full review only.

  Next Steps

  1. Select a real, released Go toolchain (e.g., 1.22.x today), update the
     Dockerfile base images, and run go mod tidy against that toolchain.
  2. Reorder or tweak middleware so CORS handles preflight before auth, and
     make /metrics public (or document the token approach).
  3. Normalize metrics labels (template paths) and fix the auth error responses’
     headers/content-type; then rerun go test ./... once the build toolchain
     is sane.
