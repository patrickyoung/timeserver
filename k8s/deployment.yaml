apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: timeservice
  labels:
    app: timeservice
spec:
  # SQLite requires single instance due to file-based locking
  # For horizontal scaling, consider migrating to PostgreSQL/MySQL
  replicas: 1
  serviceName: timeservice
  selector:
    matchLabels:
      app: timeservice
  template:
    metadata:
      labels:
        app: timeservice
      annotations:
        # Prometheus scraping configuration
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      # Security: Use dedicated service account
      serviceAccountName: timeservice
      automountServiceAccountToken: false

      # Security: Pod Security Context
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        seccompProfile:
          type: RuntimeDefault

      containers:
      - name: timeservice
        # SECURITY: Use versioned tags instead of 'latest' to ensure deterministic deployments
        # For maximum security, pin to a specific digest:
        #   image: timeservice@sha256:<digest>
        # To get the digest: docker inspect --format='{{index .RepoDigests 0}}' timeservice:v1.0.0
        image: timeservice:v1.0.0
        imagePullPolicy: Always

        # Security: Container Security Context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 10001
          runAsGroup: 10001
          capabilities:
            drop:
              - ALL
          seccompProfile:
            type: RuntimeDefault

        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: metrics
          containerPort: 8080
          protocol: TCP

        env:
        - name: PORT
          value: "8080"
        # SECURITY: Set explicit CORS origins - REQUIRED
        # Replace with your actual frontend origins
        - name: ALLOWED_ORIGINS
          value: "https://example.com,https://app.example.com"

        # Database configuration
        - name: DB_PATH
          value: "/app/data/timeservice.db"
        - name: DB_MAX_OPEN_CONNS
          value: "25"
        - name: DB_MAX_IDLE_CONNS
          value: "5"
        - name: DB_CACHE_SIZE_KB
          value: "64000"
        - name: DB_WAL_MODE
          value: "true"

        # SECURITY: Authentication & Authorization (OAuth2/OIDC)
        # Uncomment and configure for production deployments
        # See docs/SECURITY.md for detailed setup instructions
        # - name: AUTH_ENABLED
        #   value: "true"
        # - name: OIDC_ISSUER_URL
        #   value: "https://your-auth-provider.example.com"
        # - name: OIDC_AUDIENCE
        #   value: "timeservice"
        # - name: AUTH_PUBLIC_PATHS
        #   value: "/health,/,/metrics"
        # - name: AUTH_REQUIRED_ROLE
        #   value: "time-reader"

        # Alternative: Use Kubernetes Secrets for sensitive auth config
        # - name: OIDC_ISSUER_URL
        #   valueFrom:
        #     secretKeyRef:
        #       name: timeservice-auth
        #       key: oidc-issuer-url
        # - name: OIDC_AUDIENCE
        #   valueFrom:
        #     secretKeyRef:
        #       name: timeservice-auth
        #       key: oidc-audience

        # Resource limits
        resources:
          limits:
            cpu: 500m
            memory: 128Mi
          requests:
            cpu: 100m
            memory: 64Mi

        # Liveness probe using dedicated healthcheck binary
        livenessProbe:
          exec:
            command:
            - /app/healthcheck
          initialDelaySeconds: 5
          periodSeconds: 30
          timeoutSeconds: 3
          failureThreshold: 3

        # Readiness probe using dedicated healthcheck binary
        readinessProbe:
          exec:
            command:
            - /app/healthcheck
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3

        # Volume mounts for writable directories
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: cache
          mountPath: /.cache
        - name: data
          mountPath: /app/data

      # Volumes
      volumes:
      - name: tmp
        emptyDir:
          sizeLimit: 10Mi
      - name: cache
        emptyDir:
          sizeLimit: 10Mi

  # PersistentVolumeClaim template for database storage
  # Each StatefulSet pod gets its own PVC for stable storage
  volumeClaimTemplates:
  - metadata:
      name: data
      labels:
        app: timeservice
    spec:
      accessModes: [ "ReadWriteOnce" ]
      # Optional: Specify storage class for specific provisioners
      # storageClassName: "fast-ssd"
      resources:
        requests:
          storage: 1Gi

---
apiVersion: v1
kind: Service
metadata:
  name: timeservice
  labels:
    app: timeservice
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: timeservice

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: timeservice
automountServiceAccountToken: false

---
# ServiceMonitor for Prometheus Operator
# This enables automatic Prometheus scraping when using Prometheus Operator
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: timeservice
  labels:
    app: timeservice
spec:
  selector:
    matchLabels:
      app: timeservice
  endpoints:
  - port: http
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
